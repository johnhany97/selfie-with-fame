#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('selfiewithfame:server');
var https = require('https');
var fs = require('fs-extra');
const express = require('express');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

/**
 * Create HTTPs server.
 */
var options = {
  key: fs.readFileSync('./private_access/ca.key'),
  cert: fs.readFileSync('./private_access/ca.crt')
};

/**
 * Create HTTPs server using the options
 */
var server = https.createServer(options, app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);

// use socket io
let io = require('socket.io').listen(server);
app.set('io', io);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTPs server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTPs server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

const Connection = require('../models/connection');
const User = require('../models/user');
const Story = require('../models/story');
const NewsFeed = require('../models/newsfeed');
const sanitizeHtml = require('sanitize-html');

io.on('connect' , (socket) => {
  socket.on('connected', async (username) => {
    // Remove any of their old connections
    await Connection.remove({user: username});
    // Add new connection
    const connection = new Connection({
      socketId: socket.id,
      user: username,
    });
    connection.save();
  });

  socket.on('disconnect', () => {
    Connection.findOne({ socketId: socket.id }).remove().exec();
  });

  socket.on('post_story', async (body) => {
    const username = body.username;
    const user = await User.findOne({ username });

    const picturesParam = body.pictures;

    let pictureBuffers = [];

    if (picturesParam) {
      for (let i = 0; i < picturesParam.length; i++) {
        let pictureBlob = picturesParam[i].replace(/^data:image\/\w+;base64,/, '');
        pictureBuffers.push(new Buffer(pictureBlob, 'base64'));
      }
    }

    const story = new Story({
      text: sanitizeHtml(body.text),
      pictures: pictureBuffers,
      event: body.event_id,
      postedBy: user._id
    });

    story.save()
      .then((story) => {
        // Add to news feed
        User.findById(user._id)
          .then(async (user) => {
            // 1- Get Followers
            let followers = user.followers;
            // 2- Create entries for them
            let newsFeed = followers.map((follower) => {
              return {
                owner: follower._id,
                story: story._id
              };
            });
            // 3- Save these entries
            await NewsFeed.insertMany(newsFeed);
            // 4- Inform the followers there's an update using Sockets
            followers.map(async (follower) => {
              const user = await User.findById(follower);
              Connection.findOne({ user: user.username })
                .then((connection) => {
                  if (connection) {
                    io.to(connection.socketId).emit('new_story');
                  }
                })
            })
          });
      })
      .catch((e) => {
        res.status(400).send(e);
      });
  });
});
